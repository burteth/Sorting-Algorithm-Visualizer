'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));
var warning = _interopDefault(require('warning'));
var autoId = require('@reach/auto-id');
var utils = require('@reach/utils');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

(function (SliderOrientation) {
  SliderOrientation["Horizontal"] = "horizontal";
  SliderOrientation["Vertical"] = "vertical";
})(exports.SliderOrientation || (exports.SliderOrientation = {}));

(function (SliderHandleAlignment) {
  // Handle is centered directly over the current value marker
  SliderHandleAlignment["Center"] = "center"; // Handle is contained within the bounds of the track, offset slightly from
  // the value's center mark to accommodate

  SliderHandleAlignment["Contain"] = "contain";
})(exports.SliderHandleAlignment || (exports.SliderHandleAlignment = {})); // TODO: Remove in 1.0, maybe?


var SLIDER_ORIENTATION_HORIZONTAL = exports.SliderOrientation.Horizontal;
var SLIDER_ORIENTATION_VERTICAL = exports.SliderOrientation.Vertical;
var SLIDER_HANDLE_ALIGN_CENTER = exports.SliderHandleAlignment.Center;
var SLIDER_HANDLE_ALIGN_CONTAIN = exports.SliderHandleAlignment.Contain;
var SliderContext = /*#__PURE__*/utils.createNamedContext("SliderContext", {});

var useSliderContext = function useSliderContext() {
  return React.useContext(SliderContext);
}; // These proptypes are shared between the composed SliderInput component and the
// simplified Slider


var sliderPropTypes = {
  defaultValue: PropTypes.number,
  disabled: PropTypes.bool,
  getValueText: PropTypes.func,
  handleAlignment: /*#__PURE__*/PropTypes.oneOf([exports.SliderHandleAlignment.Center, exports.SliderHandleAlignment.Contain]),
  min: PropTypes.number,
  max: PropTypes.number,
  name: PropTypes.string,
  orientation: /*#__PURE__*/PropTypes.oneOf([exports.SliderOrientation.Horizontal, exports.SliderOrientation.Vertical]),
  onChange: PropTypes.func,
  step: PropTypes.number,
  value: PropTypes.number
}; ////////////////////////////////////////////////////////////////////////////////

/**
 * Slider
 *
 * @see Docs https://reacttraining.com/reach-ui/slider#slider
 */

var Slider = /*#__PURE__*/React.forwardRef(function Slider(_ref, forwardedRef) {
  var children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return React__default.createElement(SliderInput, Object.assign({
    ref: forwardedRef,
    "data-reach-slider": ""
  }, props), React__default.createElement(SliderTrack, null, React__default.createElement(SliderTrackHighlight, null), React__default.createElement(SliderHandle, null), children));
});

{
  Slider.displayName = "Slider";
  Slider.propTypes = /*#__PURE__*/_extends({}, sliderPropTypes, {
    children: PropTypes.node
  });
}

/**
 * SliderInput
 *
 * The parent component of the slider interface. This is a lower level component
 * if you need more control over styles or rendering the slider's inner
 * components.
 *
 * @see Docs https://reacttraining.com/reach-ui/slider#sliderinput
 */

var SliderInput = /*#__PURE__*/React.forwardRef(function SliderInput(_ref2, forwardedRef) {
  var ariaLabel = _ref2["aria-label"],
      ariaLabelledBy = _ref2["aria-labelledby"],
      ariaValueText = _ref2["aria-valuetext"],
      defaultValue = _ref2.defaultValue,
      _ref2$disabled = _ref2.disabled,
      disabled = _ref2$disabled === void 0 ? false : _ref2$disabled,
      controlledValue = _ref2.value,
      getValueText = _ref2.getValueText,
      _ref2$handleAlignment = _ref2.handleAlignment,
      handleAlignment = _ref2$handleAlignment === void 0 ? exports.SliderHandleAlignment.Center : _ref2$handleAlignment,
      _ref2$max = _ref2.max,
      max = _ref2$max === void 0 ? 100 : _ref2$max,
      _ref2$min = _ref2.min,
      min = _ref2$min === void 0 ? 0 : _ref2$min,
      name = _ref2.name,
      onChange = _ref2.onChange,
      onKeyDown = _ref2.onKeyDown,
      onPointerDown = _ref2.onPointerDown,
      onPointerMove = _ref2.onPointerMove,
      onPointerUp = _ref2.onPointerUp,
      _ref2$orientation = _ref2.orientation,
      orientation = _ref2$orientation === void 0 ? exports.SliderOrientation.Horizontal : _ref2$orientation,
      stepProp = _ref2.step,
      children = _ref2.children,
      rest = _objectWithoutPropertiesLoose(_ref2, ["aria-label", "aria-labelledby", "aria-valuetext", "defaultValue", "disabled", "value", "getValueText", "handleAlignment", "max", "min", "name", "onChange", "onKeyDown", "onPointerDown", "onPointerMove", "onPointerUp", "orientation", "step", "children"]);

  // Verify that the component is either controlled or uncontrolled throughout
  // its lifecycle
  var _useRef = React.useRef(controlledValue != null),
      isControlled = _useRef.current;

   warning(!(isControlled && controlledValue == null), "Slider is changing from controlled to uncontrolled. Slider should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Slider for the lifetime of the component. Check the `value` prop being passed in.") ;
   warning(!(!isControlled && controlledValue != null), "Slider is changing from uncontrolled to controlled. Slider should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled Slider for the lifetime of the component. Check the `value` prop being passed in.") ;
  var id = autoId.useId(rest.id);
  var trackRef = React.useRef(null);
  var handleRef = React.useRef(null);
  var sliderRef = React.useRef(null);
  var ref = utils.useForkedRef(sliderRef, forwardedRef);

  var _useState = React.useState(false),
      hasFocus = _useState[0],
      setHasFocus = _useState[1];

  var _useState2 = React.useState(false),
      isPointerDown = _useState2[0],
      setPointerDown = _useState2[1];

  var _useState3 = React.useState(defaultValue || min),
      internalValue = _useState3[0],
      setValue = _useState3[1];

  var _useDimensions = useDimensions(handleRef),
      handleDimensions = _objectWithoutPropertiesLoose(_useDimensions, ["ref"]);

  var _value = isControlled ? controlledValue : internalValue;

  var value = getAllowedValue(_value, min, max);
  var trackPercent = valueToPercent(value, min, max);
  var isVertical = orientation === exports.SliderOrientation.Vertical;
  var step = stepProp || 1;
  var handleSize = isVertical ? handleDimensions.height : handleDimensions.width;
  var handlePosition = "calc(" + trackPercent + "% - " + (handleAlignment === exports.SliderHandleAlignment.Center ? handleSize + "px / 2" : handleSize + "px * " + trackPercent * 0.01) + ")";
  var updateValue = React.useCallback(function updateValue(newValue) {
    if (!isControlled) {
      setValue(newValue);
    }

    if (onChange) {
      onChange(newValue, {
        min: min,
        max: max,
        handlePosition: handlePosition
      });
    }
  }, [handlePosition, isControlled, max, min, onChange]);
  var getNewValueFromPointer = React.useCallback(function (event) {
    if (trackRef.current) {
      var _trackRef$current$get = trackRef.current.getBoundingClientRect(),
          left = _trackRef$current$get.left,
          width = _trackRef$current$get.width,
          bottom = _trackRef$current$get.bottom,
          height = _trackRef$current$get.height;

      var clientX = event.clientX,
          clientY = event.clientY;
      var diff = isVertical ? bottom - clientY : clientX - left;
      var percent = diff / (isVertical ? height : width);
      var newValue = percentToValue(percent, min, max);

      if (step) {
        newValue = roundValueToStep(newValue, step);
      }

      newValue = getAllowedValue(newValue, min, max);
      return newValue;
    }

    return null;
  }, [isVertical, max, min, step]); // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_kbd_interaction

  var handleKeyDown = utils.wrapEvent(onKeyDown, function (event) {
    var flag = false;
    var newValue;
    var tenSteps = (max - min) / 10;
    var keyStep = stepProp || (max - min) / 100;

    switch (event.key) {
      // Decrease the value of the slider by one step.
      case "ArrowLeft":
      case "ArrowDown":
        newValue = value - keyStep;
        flag = true;
        break;
      // Increase the value of the slider by one step

      case "ArrowRight":
      case "ArrowUp":
        newValue = value + keyStep;
        flag = true;
        break;
      // Decrement the slider by an amount larger than the step change made by
      // `ArrowDown`.

      case "PageDown":
        newValue = value - tenSteps;
        flag = true;
        break;
      // Increment the slider by an amount larger than the step change made by
      // `ArrowUp`.

      case "PageUp":
        newValue = value + tenSteps;
        flag = true;
        break;
      // Set the slider to the first allowed value in its range.

      case "Home":
        newValue = min;
        flag = true;
        break;
      // Set the slider to the last allowed value in its range.

      case "End":
        newValue = max;
        flag = true;
        break;

      default:
        return;
    }

    if (flag) {
      event.preventDefault();
      newValue = roundValueToStep(newValue, keyStep);
      newValue = getAllowedValue(newValue, min, max);
      updateValue(newValue);
    }
  });
  var handlePointerDown = utils.wrapEvent(onPointerDown, function (event) {
    event.preventDefault();

    if (disabled) {
      if (isPointerDown) setPointerDown(false);
      return;
    }

    if (sliderRef.current && handleRef.current) {
      setPointerDown(true);
      var newValue = getNewValueFromPointer(event);
      sliderRef.current.setPointerCapture && sliderRef.current.setPointerCapture(event.pointerId);

      if (newValue != null && newValue !== value) {
        updateValue(newValue);
      }

      handleRef.current.focus();
    }
  });
  var handlePointerUp = utils.wrapEvent(onPointerUp, function (event) {
    if (sliderRef.current && event.pointerId) {
      sliderRef.current.releasePointerCapture && sliderRef.current.releasePointerCapture(event.pointerId);
    }

    setPointerDown(false);
  });
  var valueText = getValueText ? getValueText(value) : ariaValueText;
  var trackHighlightStyle = isVertical ? {
    width: "100%",
    height: trackPercent + "%",
    bottom: 0
  } : {
    width: trackPercent + "%",
    height: "100%",
    left: 0
  };
  var ctx = {
    ariaLabel: ariaLabel,
    ariaLabelledBy: ariaLabelledBy,
    handleDimensions: handleDimensions,
    handlePosition: handlePosition,
    handleRef: handleRef,
    hasFocus: hasFocus,
    onKeyDown: onKeyDown,
    onPointerDown: onPointerDown,
    onPointerMove: onPointerMove,
    onPointerUp: onPointerUp,
    onHandleKeyDown: handleKeyDown,
    setHasFocus: setHasFocus,
    sliderId: id,
    sliderMax: max,
    sliderMin: min,
    value: value,
    valueText: valueText,
    disabled: !!disabled,
    isVertical: isVertical,
    orientation: orientation,
    sliderStep: step,
    trackPercent: trackPercent,
    trackRef: trackRef,
    trackHighlightStyle: trackHighlightStyle,
    updateValue: updateValue
  };
  React.useEffect(function () {
    var ownerDocument = utils.getOwnerDocument(sliderRef.current) || document;
    var handlePointerMove = utils.wrapEvent(onPointerMove, function (event) {
      var newValue = getNewValueFromPointer(event);

      if (newValue !== value) {
        updateValue(newValue);
      }
    });

    if (isPointerDown) {
      ownerDocument.addEventListener("pointermove", handlePointerMove);
    }

    return function () {
      ownerDocument.removeEventListener("pointermove", handlePointerMove);
    };
  }, [getNewValueFromPointer, isPointerDown, onPointerMove, updateValue, value]);
  React.useEffect(function () {
    return utils.checkStyles("slider");
  }, []);
  return React__default.createElement(SliderContext.Provider, {
    value: ctx
  }, React__default.createElement("div", Object.assign({}, rest, {
    ref: ref,
    "data-reach-slider-input": "",
    "data-disabled": disabled ? "" : undefined,
    "data-orientation": orientation,
    tabIndex: -1,
    onPointerDown: handlePointerDown,
    onPointerUp: handlePointerUp
  }), utils.isFunction(children) ? children({
    hasFocus: hasFocus,
    id: id,
    max: max,
    min: min,
    value: value,
    valueText: valueText
  }) : children, name && // If the slider is used in a form we'll need an input field to
  // capture the value. We'll assume this when the component is given a
  // form field name (A `name` prop doesn't really make sense in any
  // other context).
  React__default.createElement("input", {
    type: "hidden",
    value: value,
    name: name,
    id: id && utils.makeId("input", id)
  })));
});

{
  SliderInput.displayName = "SliderInput";
  SliderInput.propTypes = /*#__PURE__*/_extends({}, sliderPropTypes, {
    children: /*#__PURE__*/PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired
  });
} ////////////////////////////////////////////////////////////////////////////////

/**
 * SliderTrack
 *
 * @see Docs https://reacttraining.com/reach-ui/slider#slidertrack
 */


var SliderTrack = /*#__PURE__*/React.forwardRef(function SliderTrack(_ref3, forwardedRef) {
  var children = _ref3.children,
      _ref3$style = _ref3.style,
      style = _ref3$style === void 0 ? {} : _ref3$style,
      props = _objectWithoutPropertiesLoose(_ref3, ["children", "style"]);

  var _useSliderContext = useSliderContext(),
      disabled = _useSliderContext.disabled,
      orientation = _useSliderContext.orientation,
      trackRef = _useSliderContext.trackRef;

  var ref = utils.useForkedRef(trackRef, forwardedRef);
  return React__default.createElement("div", Object.assign({
    ref: ref,
    style: _extends({}, style, {
      position: "relative"
    })
  }, props, {
    "data-reach-slider-track": "",
    "data-disabled": disabled ? "" : undefined,
    "data-orientation": orientation
  }), children);
});

{
  SliderTrack.displayName = "SliderTrack";
  SliderTrack.propTypes = {
    children: PropTypes.node.isRequired
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * SliderTrackHighlight
 *
 * The (typically) highlighted portion of the track that represents the space
 * between the slider's `min` value and its current value.
 *
 * TODO: Consider renaming to `SliderTrackProgress`
 *
 * @see Docs https://reacttraining.com/reach-ui/slider#slidertrackhighlight
 */


var SliderTrackHighlight = /*#__PURE__*/React.forwardRef(function SliderTrackHighlight(_ref4, forwardedRef) {
  var children = _ref4.children,
      _ref4$style = _ref4.style,
      style = _ref4$style === void 0 ? {} : _ref4$style,
      props = _objectWithoutPropertiesLoose(_ref4, ["children", "style"]);

  var _useSliderContext2 = useSliderContext(),
      disabled = _useSliderContext2.disabled,
      orientation = _useSliderContext2.orientation,
      trackHighlightStyle = _useSliderContext2.trackHighlightStyle;

  return React__default.createElement("div", Object.assign({
    ref: forwardedRef,
    style: _extends({
      position: "absolute"
    }, trackHighlightStyle, {}, style)
  }, props, {
    "data-reach-slider-track-highlight": "",
    "data-disabled": disabled ? "" : undefined,
    "data-orientation": orientation
  }));
});

{
  SliderTrackHighlight.displayName = "SliderTrackHighlight";
  SliderTrackHighlight.propTypes = {};
} ////////////////////////////////////////////////////////////////////////////////

/**
 * SliderHandle
 *
 * The handle that the user drags along the track to set the slider value.
 *
 * @see Docs https://reacttraining.com/reach-ui/slider#sliderhandle
 */


var SliderHandle = /*#__PURE__*/React.forwardRef(function SliderHandle(_ref5, forwardedRef) {
  var onBlur = _ref5.onBlur,
      onFocus = _ref5.onFocus,
      _ref5$style = _ref5.style,
      style = _ref5$style === void 0 ? {} : _ref5$style,
      onKeyDown = _ref5.onKeyDown,
      props = _objectWithoutPropertiesLoose(_ref5, ["onBlur", "onFocus", "style", "onKeyDown"]);

  var _useSliderContext3 = useSliderContext(),
      ariaLabel = _useSliderContext3.ariaLabel,
      ariaLabelledBy = _useSliderContext3.ariaLabelledBy,
      disabled = _useSliderContext3.disabled,
      handlePosition = _useSliderContext3.handlePosition,
      handleRef = _useSliderContext3.handleRef,
      isVertical = _useSliderContext3.isVertical,
      onHandleKeyDown = _useSliderContext3.onHandleKeyDown,
      orientation = _useSliderContext3.orientation,
      setHasFocus = _useSliderContext3.setHasFocus,
      sliderMin = _useSliderContext3.sliderMin,
      sliderMax = _useSliderContext3.sliderMax,
      value = _useSliderContext3.value,
      valueText = _useSliderContext3.valueText;

  var ref = utils.useForkedRef(handleRef, forwardedRef);
  return React__default.createElement("div", Object.assign({
    "aria-disabled": disabled || undefined,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabel ? undefined : ariaLabelledBy,
    "aria-orientation": orientation,
    "aria-valuemax": sliderMax,
    "aria-valuemin": sliderMin,
    "aria-valuenow": value,
    "aria-valuetext": valueText,
    // The element serving as the focusable slider control has role
    // `slider`.
    // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props
    role: "slider",
    tabIndex: disabled ? -1 : 0
  }, props, {
    "data-reach-slider-handle": "",
    ref: ref,
    onBlur: utils.wrapEvent(onBlur, function () {
      setHasFocus(false);
    }),
    onFocus: utils.wrapEvent(onFocus, function () {
      setHasFocus(true);
    }),
    onKeyDown: utils.wrapEvent(onKeyDown, onHandleKeyDown),
    style: _extends({
      position: "absolute"
    }, isVertical ? {
      bottom: handlePosition
    } : {
      left: handlePosition
    }, {}, style)
  }));
});

{
  SliderHandle.displayName = "SliderHandle";
  SliderHandle.propTypes = {};
} ////////////////////////////////////////////////////////////////////////////////

/**
 * SliderMarker
 *
 * A fixed value marker. These can be used to illustrate a range of steps or
 * highlight important points along the slider track.
 *
 * @see Docs https://reacttraining.com/reach-ui/slider#slidermarker
 */


var SliderMarker = /*#__PURE__*/React.forwardRef(function SliderMarker(_ref6, forwardedRef) {
  var children = _ref6.children,
      _ref6$style = _ref6.style,
      style = _ref6$style === void 0 ? {} : _ref6$style,
      value = _ref6.value,
      props = _objectWithoutPropertiesLoose(_ref6, ["children", "style", "value"]);

  var _useSliderContext4 = useSliderContext(),
      disabled = _useSliderContext4.disabled,
      isVertical = _useSliderContext4.isVertical,
      orientation = _useSliderContext4.orientation,
      sliderMin = _useSliderContext4.sliderMin,
      sliderMax = _useSliderContext4.sliderMax,
      sliderValue = _useSliderContext4.value;

  var inRange = !(value < sliderMin || value > sliderMax);
  var absoluteStartPosition = valueToPercent(value, sliderMin, sliderMax) + "%";
  var state = value < sliderValue ? "under-value" : value === sliderValue ? "at-value" : "over-value";
  return inRange ? React__default.createElement("div", Object.assign({
    ref: forwardedRef,
    style: _extends({
      position: "absolute"
    }, isVertical ? {
      bottom: absoluteStartPosition
    } : {
      left: absoluteStartPosition
    }, {}, style)
  }, props, {
    "data-reach-slider-marker": "",
    "data-disabled": disabled ? "" : undefined,
    "data-orientation": orientation,
    "data-state": state,
    "data-value": value,
    children: children
  })) : null;
});

{
  SliderMarker.displayName = "SliderMarker";
  SliderMarker.propTypes = {
    value: PropTypes.number.isRequired
  };
} ////////////////////////////////////////////////////////////////////////////////


function getAllowedValue(val, min, max) {
  return val > max ? max : val < min ? min : val;
}

function makeValuePrecise(value, step) {
  var stepDecimalPart = step.toString().split(".")[1];
  var stepPrecision = stepDecimalPart ? stepDecimalPart.length : 0;
  return Number(value.toFixed(stepPrecision));
}

function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}

function roundValueToStep(value, step) {
  return makeValuePrecise(Math.round(value / step) * step, step);
}

function useDimensions(ref) {
  var _useState4 = React.useState({
    width: 0,
    height: 0
  }),
      _useState4$ = _useState4[0],
      width = _useState4$.width,
      height = _useState4$.height,
      setDimensions = _useState4[1]; // Many existing `useDimensions` type hooks will use `getBoundingClientRect`
  // getBoundingClientRect does not work here when borders are applied.
  // getComputedStyle is not as performant so we may want to create a utility to
  // check for any conflicts with box sizing first and only use
  // `getComputedStyle` if neccessary.

  /* const { width, height } = ref.current
    ? ref.current.getBoundingClientRect()
    : 0; */


  utils.useIsomorphicLayoutEffect(function () {
    if (ref.current) {
      var _window$getComputedSt = window.getComputedStyle(ref.current),
          _newHeight = _window$getComputedSt.height,
          _newWidth = _window$getComputedSt.width;

      var newHeight = parseFloat(_newHeight);
      var newWidth = parseFloat(_newWidth);

      if (newHeight !== height || newWidth !== width) {
        setDimensions({
          height: newHeight,
          width: newWidth
        });
      }
    }
  }, [ref, width, height]);
  return {
    ref: ref,
    width: width,
    height: height
  };
}

function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}

exports.SLIDER_HANDLE_ALIGN_CENTER = SLIDER_HANDLE_ALIGN_CENTER;
exports.SLIDER_HANDLE_ALIGN_CONTAIN = SLIDER_HANDLE_ALIGN_CONTAIN;
exports.SLIDER_ORIENTATION_HORIZONTAL = SLIDER_ORIENTATION_HORIZONTAL;
exports.SLIDER_ORIENTATION_VERTICAL = SLIDER_ORIENTATION_VERTICAL;
exports.Slider = Slider;
exports.SliderHandle = SliderHandle;
exports.SliderInput = SliderInput;
exports.SliderMarker = SliderMarker;
exports.SliderTrack = SliderTrack;
exports.SliderTrackHighlight = SliderTrackHighlight;
exports.default = Slider;
//# sourceMappingURL=slider.cjs.development.js.map
