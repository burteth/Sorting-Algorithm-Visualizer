{"ast":null,"code":"import React, { forwardRef, useRef, useState, useCallback, useEffect, useContext } from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport { useId } from '@reach/auto-id';\nimport { useForkedRef, wrapEvent, getOwnerDocument, checkStyles, isFunction, makeId, useIsomorphicLayoutEffect, createNamedContext } from '@reach/utils';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar SliderOrientation;\n\n(function (SliderOrientation) {\n  SliderOrientation[\"Horizontal\"] = \"horizontal\";\n  SliderOrientation[\"Vertical\"] = \"vertical\";\n})(SliderOrientation || (SliderOrientation = {}));\n\nvar SliderHandleAlignment;\n\n(function (SliderHandleAlignment) {\n  // Handle is centered directly over the current value marker\n  SliderHandleAlignment[\"Center\"] = \"center\"; // Handle is contained within the bounds of the track, offset slightly from\n  // the value's center mark to accommodate\n\n  SliderHandleAlignment[\"Contain\"] = \"contain\";\n})(SliderHandleAlignment || (SliderHandleAlignment = {})); // TODO: Remove in 1.0, maybe?\n\n\nvar SLIDER_ORIENTATION_HORIZONTAL = SliderOrientation.Horizontal;\nvar SLIDER_ORIENTATION_VERTICAL = SliderOrientation.Vertical;\nvar SLIDER_HANDLE_ALIGN_CENTER = SliderHandleAlignment.Center;\nvar SLIDER_HANDLE_ALIGN_CONTAIN = SliderHandleAlignment.Contain;\nvar SliderContext = /*#__PURE__*/createNamedContext(\"SliderContext\", {});\n\nvar useSliderContext = function useSliderContext() {\n  return useContext(SliderContext);\n}; // These proptypes are shared between the composed SliderInput component and the\n// simplified Slider\n\n\nvar sliderPropTypes = {\n  defaultValue: PropTypes.number,\n  disabled: PropTypes.bool,\n  getValueText: PropTypes.func,\n  handleAlignment: /*#__PURE__*/PropTypes.oneOf([SliderHandleAlignment.Center, SliderHandleAlignment.Contain]),\n  min: PropTypes.number,\n  max: PropTypes.number,\n  name: PropTypes.string,\n  orientation: /*#__PURE__*/PropTypes.oneOf([SliderOrientation.Horizontal, SliderOrientation.Vertical]),\n  onChange: PropTypes.func,\n  step: PropTypes.number,\n  value: PropTypes.number\n}; ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * Slider\r\n *\r\n * @see Docs https://reacttraining.com/reach-ui/slider#slider\r\n */\n\nvar Slider = /*#__PURE__*/forwardRef(function Slider(_ref, forwardedRef) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return React.createElement(SliderInput, Object.assign({\n    ref: forwardedRef,\n    \"data-reach-slider\": \"\"\n  }, props), React.createElement(SliderTrack, null, React.createElement(SliderTrackHighlight, null), React.createElement(SliderHandle, null), children));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  Slider.displayName = \"Slider\";\n  Slider.propTypes = /*#__PURE__*/_extends({}, sliderPropTypes, {\n    children: PropTypes.node\n  });\n}\n/**\r\n * SliderInput\r\n *\r\n * The parent component of the slider interface. This is a lower level component\r\n * if you need more control over styles or rendering the slider's inner\r\n * components.\r\n *\r\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderinput\r\n */\n\n\nvar SliderInput = /*#__PURE__*/forwardRef(function SliderInput(_ref2, forwardedRef) {\n  var ariaLabel = _ref2[\"aria-label\"],\n      ariaLabelledBy = _ref2[\"aria-labelledby\"],\n      ariaValueText = _ref2[\"aria-valuetext\"],\n      defaultValue = _ref2.defaultValue,\n      _ref2$disabled = _ref2.disabled,\n      disabled = _ref2$disabled === void 0 ? false : _ref2$disabled,\n      controlledValue = _ref2.value,\n      getValueText = _ref2.getValueText,\n      _ref2$handleAlignment = _ref2.handleAlignment,\n      handleAlignment = _ref2$handleAlignment === void 0 ? SliderHandleAlignment.Center : _ref2$handleAlignment,\n      _ref2$max = _ref2.max,\n      max = _ref2$max === void 0 ? 100 : _ref2$max,\n      _ref2$min = _ref2.min,\n      min = _ref2$min === void 0 ? 0 : _ref2$min,\n      name = _ref2.name,\n      onChange = _ref2.onChange,\n      onKeyDown = _ref2.onKeyDown,\n      onPointerDown = _ref2.onPointerDown,\n      onPointerMove = _ref2.onPointerMove,\n      onPointerUp = _ref2.onPointerUp,\n      _ref2$orientation = _ref2.orientation,\n      orientation = _ref2$orientation === void 0 ? SliderOrientation.Horizontal : _ref2$orientation,\n      stepProp = _ref2.step,\n      children = _ref2.children,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"aria-label\", \"aria-labelledby\", \"aria-valuetext\", \"defaultValue\", \"disabled\", \"value\", \"getValueText\", \"handleAlignment\", \"max\", \"min\", \"name\", \"onChange\", \"onKeyDown\", \"onPointerDown\", \"onPointerMove\", \"onPointerUp\", \"orientation\", \"step\", \"children\"]); // Verify that the component is either controlled or uncontrolled throughout\n  // its lifecycle\n\n\n  var _useRef = useRef(controlledValue != null),\n      isControlled = _useRef.current;\n\n  process.env.NODE_ENV !== \"production\" ? warning(!(isControlled && controlledValue == null), \"Slider is changing from controlled to uncontrolled. Slider should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Slider for the lifetime of the component. Check the `value` prop being passed in.\") : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(!(!isControlled && controlledValue != null), \"Slider is changing from uncontrolled to controlled. Slider should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled Slider for the lifetime of the component. Check the `value` prop being passed in.\") : void 0;\n  var id = useId(rest.id);\n  var trackRef = useRef(null);\n  var handleRef = useRef(null);\n  var sliderRef = useRef(null);\n  var ref = useForkedRef(sliderRef, forwardedRef);\n\n  var _useState = useState(false),\n      hasFocus = _useState[0],\n      setHasFocus = _useState[1];\n\n  var _useState2 = useState(false),\n      isPointerDown = _useState2[0],\n      setPointerDown = _useState2[1];\n\n  var _useState3 = useState(defaultValue || min),\n      internalValue = _useState3[0],\n      setValue = _useState3[1];\n\n  var _useDimensions = useDimensions(handleRef),\n      handleDimensions = _objectWithoutPropertiesLoose(_useDimensions, [\"ref\"]);\n\n  var _value = isControlled ? controlledValue : internalValue;\n\n  var value = getAllowedValue(_value, min, max);\n  var trackPercent = valueToPercent(value, min, max);\n  var isVertical = orientation === SliderOrientation.Vertical;\n  var step = stepProp || 1;\n  var handleSize = isVertical ? handleDimensions.height : handleDimensions.width;\n  var handlePosition = \"calc(\" + trackPercent + \"% - \" + (handleAlignment === SliderHandleAlignment.Center ? handleSize + \"px / 2\" : handleSize + \"px * \" + trackPercent * 0.01) + \")\";\n  var updateValue = useCallback(function updateValue(newValue) {\n    if (!isControlled) {\n      setValue(newValue);\n    }\n\n    if (onChange) {\n      onChange(newValue, {\n        min: min,\n        max: max,\n        handlePosition: handlePosition\n      });\n    }\n  }, [handlePosition, isControlled, max, min, onChange]);\n  var getNewValueFromPointer = useCallback(function (event) {\n    if (trackRef.current) {\n      var _trackRef$current$get = trackRef.current.getBoundingClientRect(),\n          left = _trackRef$current$get.left,\n          width = _trackRef$current$get.width,\n          bottom = _trackRef$current$get.bottom,\n          height = _trackRef$current$get.height;\n\n      var clientX = event.clientX,\n          clientY = event.clientY;\n      var diff = isVertical ? bottom - clientY : clientX - left;\n      var percent = diff / (isVertical ? height : width);\n      var newValue = percentToValue(percent, min, max);\n\n      if (step) {\n        newValue = roundValueToStep(newValue, step);\n      }\n\n      newValue = getAllowedValue(newValue, min, max);\n      return newValue;\n    }\n\n    return null;\n  }, [isVertical, max, min, step]); // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_kbd_interaction\n\n  var handleKeyDown = wrapEvent(onKeyDown, function (event) {\n    var flag = false;\n    var newValue;\n    var tenSteps = (max - min) / 10;\n    var keyStep = stepProp || (max - min) / 100;\n\n    switch (event.key) {\n      // Decrease the value of the slider by one step.\n      case \"ArrowLeft\":\n      case \"ArrowDown\":\n        newValue = value - keyStep;\n        flag = true;\n        break;\n      // Increase the value of the slider by one step\n\n      case \"ArrowRight\":\n      case \"ArrowUp\":\n        newValue = value + keyStep;\n        flag = true;\n        break;\n      // Decrement the slider by an amount larger than the step change made by\n      // `ArrowDown`.\n\n      case \"PageDown\":\n        newValue = value - tenSteps;\n        flag = true;\n        break;\n      // Increment the slider by an amount larger than the step change made by\n      // `ArrowUp`.\n\n      case \"PageUp\":\n        newValue = value + tenSteps;\n        flag = true;\n        break;\n      // Set the slider to the first allowed value in its range.\n\n      case \"Home\":\n        newValue = min;\n        flag = true;\n        break;\n      // Set the slider to the last allowed value in its range.\n\n      case \"End\":\n        newValue = max;\n        flag = true;\n        break;\n\n      default:\n        return;\n    }\n\n    if (flag) {\n      event.preventDefault();\n      newValue = roundValueToStep(newValue, keyStep);\n      newValue = getAllowedValue(newValue, min, max);\n      updateValue(newValue);\n    }\n  });\n  var handlePointerDown = wrapEvent(onPointerDown, function (event) {\n    event.preventDefault();\n\n    if (disabled) {\n      if (isPointerDown) setPointerDown(false);\n      return;\n    }\n\n    if (sliderRef.current && handleRef.current) {\n      setPointerDown(true);\n      var newValue = getNewValueFromPointer(event);\n      sliderRef.current.setPointerCapture && sliderRef.current.setPointerCapture(event.pointerId);\n\n      if (newValue != null && newValue !== value) {\n        updateValue(newValue);\n      }\n\n      handleRef.current.focus();\n    }\n  });\n  var handlePointerUp = wrapEvent(onPointerUp, function (event) {\n    if (sliderRef.current && event.pointerId) {\n      sliderRef.current.releasePointerCapture && sliderRef.current.releasePointerCapture(event.pointerId);\n    }\n\n    setPointerDown(false);\n  });\n  var valueText = getValueText ? getValueText(value) : ariaValueText;\n  var trackHighlightStyle = isVertical ? {\n    width: \"100%\",\n    height: trackPercent + \"%\",\n    bottom: 0\n  } : {\n    width: trackPercent + \"%\",\n    height: \"100%\",\n    left: 0\n  };\n  var ctx = {\n    ariaLabel: ariaLabel,\n    ariaLabelledBy: ariaLabelledBy,\n    handleDimensions: handleDimensions,\n    handlePosition: handlePosition,\n    handleRef: handleRef,\n    hasFocus: hasFocus,\n    onKeyDown: onKeyDown,\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp,\n    onHandleKeyDown: handleKeyDown,\n    setHasFocus: setHasFocus,\n    sliderId: id,\n    sliderMax: max,\n    sliderMin: min,\n    value: value,\n    valueText: valueText,\n    disabled: !!disabled,\n    isVertical: isVertical,\n    orientation: orientation,\n    sliderStep: step,\n    trackPercent: trackPercent,\n    trackRef: trackRef,\n    trackHighlightStyle: trackHighlightStyle,\n    updateValue: updateValue\n  };\n  useEffect(function () {\n    var ownerDocument = getOwnerDocument(sliderRef.current) || document;\n    var handlePointerMove = wrapEvent(onPointerMove, function (event) {\n      var newValue = getNewValueFromPointer(event);\n\n      if (newValue !== value) {\n        updateValue(newValue);\n      }\n    });\n\n    if (isPointerDown) {\n      ownerDocument.addEventListener(\"pointermove\", handlePointerMove);\n    }\n\n    return function () {\n      ownerDocument.removeEventListener(\"pointermove\", handlePointerMove);\n    };\n  }, [getNewValueFromPointer, isPointerDown, onPointerMove, updateValue, value]);\n  useEffect(function () {\n    return checkStyles(\"slider\");\n  }, []);\n  return React.createElement(SliderContext.Provider, {\n    value: ctx\n  }, React.createElement(\"div\", Object.assign({}, rest, {\n    ref: ref,\n    \"data-reach-slider-input\": \"\",\n    \"data-disabled\": disabled ? \"\" : undefined,\n    \"data-orientation\": orientation,\n    tabIndex: -1,\n    onPointerDown: handlePointerDown,\n    onPointerUp: handlePointerUp\n  }), isFunction(children) ? children({\n    hasFocus: hasFocus,\n    id: id,\n    max: max,\n    min: min,\n    value: value,\n    valueText: valueText\n  }) : children, name && // If the slider is used in a form we'll need an input field to\n  // capture the value. We'll assume this when the component is given a\n  // form field name (A `name` prop doesn't really make sense in any\n  // other context).\n  React.createElement(\"input\", {\n    type: \"hidden\",\n    value: value,\n    name: name,\n    id: id && makeId(\"input\", id)\n  })));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  SliderInput.displayName = \"SliderInput\";\n  SliderInput.propTypes = /*#__PURE__*/_extends({}, sliderPropTypes, {\n    children: /*#__PURE__*/PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired\n  });\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * SliderTrack\r\n *\r\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrack\r\n */\n\n\nvar SliderTrack = /*#__PURE__*/forwardRef(function SliderTrack(_ref3, forwardedRef) {\n  var children = _ref3.children,\n      _ref3$style = _ref3.style,\n      style = _ref3$style === void 0 ? {} : _ref3$style,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"children\", \"style\"]);\n\n  var _useSliderContext = useSliderContext(),\n      disabled = _useSliderContext.disabled,\n      orientation = _useSliderContext.orientation,\n      trackRef = _useSliderContext.trackRef;\n\n  var ref = useForkedRef(trackRef, forwardedRef);\n  return React.createElement(\"div\", Object.assign({\n    ref: ref,\n    style: _extends({}, style, {\n      position: \"relative\"\n    })\n  }, props, {\n    \"data-reach-slider-track\": \"\",\n    \"data-disabled\": disabled ? \"\" : undefined,\n    \"data-orientation\": orientation\n  }), children);\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  SliderTrack.displayName = \"SliderTrack\";\n  SliderTrack.propTypes = {\n    children: PropTypes.node.isRequired\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * SliderTrackHighlight\r\n *\r\n * The (typically) highlighted portion of the track that represents the space\r\n * between the slider's `min` value and its current value.\r\n *\r\n * TODO: Consider renaming to `SliderTrackProgress`\r\n *\r\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrackhighlight\r\n */\n\n\nvar SliderTrackHighlight = /*#__PURE__*/forwardRef(function SliderTrackHighlight(_ref4, forwardedRef) {\n  var children = _ref4.children,\n      _ref4$style = _ref4.style,\n      style = _ref4$style === void 0 ? {} : _ref4$style,\n      props = _objectWithoutPropertiesLoose(_ref4, [\"children\", \"style\"]);\n\n  var _useSliderContext2 = useSliderContext(),\n      disabled = _useSliderContext2.disabled,\n      orientation = _useSliderContext2.orientation,\n      trackHighlightStyle = _useSliderContext2.trackHighlightStyle;\n\n  return React.createElement(\"div\", Object.assign({\n    ref: forwardedRef,\n    style: _extends({\n      position: \"absolute\"\n    }, trackHighlightStyle, {}, style)\n  }, props, {\n    \"data-reach-slider-track-highlight\": \"\",\n    \"data-disabled\": disabled ? \"\" : undefined,\n    \"data-orientation\": orientation\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  SliderTrackHighlight.displayName = \"SliderTrackHighlight\";\n  SliderTrackHighlight.propTypes = {};\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * SliderHandle\r\n *\r\n * The handle that the user drags along the track to set the slider value.\r\n *\r\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderhandle\r\n */\n\n\nvar SliderHandle = /*#__PURE__*/forwardRef(function SliderHandle(_ref5, forwardedRef) {\n  var onBlur = _ref5.onBlur,\n      onFocus = _ref5.onFocus,\n      _ref5$style = _ref5.style,\n      style = _ref5$style === void 0 ? {} : _ref5$style,\n      onKeyDown = _ref5.onKeyDown,\n      props = _objectWithoutPropertiesLoose(_ref5, [\"onBlur\", \"onFocus\", \"style\", \"onKeyDown\"]);\n\n  var _useSliderContext3 = useSliderContext(),\n      ariaLabel = _useSliderContext3.ariaLabel,\n      ariaLabelledBy = _useSliderContext3.ariaLabelledBy,\n      disabled = _useSliderContext3.disabled,\n      handlePosition = _useSliderContext3.handlePosition,\n      handleRef = _useSliderContext3.handleRef,\n      isVertical = _useSliderContext3.isVertical,\n      onHandleKeyDown = _useSliderContext3.onHandleKeyDown,\n      orientation = _useSliderContext3.orientation,\n      setHasFocus = _useSliderContext3.setHasFocus,\n      sliderMin = _useSliderContext3.sliderMin,\n      sliderMax = _useSliderContext3.sliderMax,\n      value = _useSliderContext3.value,\n      valueText = _useSliderContext3.valueText;\n\n  var ref = useForkedRef(handleRef, forwardedRef);\n  return React.createElement(\"div\", Object.assign({\n    \"aria-disabled\": disabled || undefined,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n    \"aria-orientation\": orientation,\n    \"aria-valuemax\": sliderMax,\n    \"aria-valuemin\": sliderMin,\n    \"aria-valuenow\": value,\n    \"aria-valuetext\": valueText,\n    // The element serving as the focusable slider control has role\n    // `slider`.\n    // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n    role: \"slider\",\n    tabIndex: disabled ? -1 : 0\n  }, props, {\n    \"data-reach-slider-handle\": \"\",\n    ref: ref,\n    onBlur: wrapEvent(onBlur, function () {\n      setHasFocus(false);\n    }),\n    onFocus: wrapEvent(onFocus, function () {\n      setHasFocus(true);\n    }),\n    onKeyDown: wrapEvent(onKeyDown, onHandleKeyDown),\n    style: _extends({\n      position: \"absolute\"\n    }, isVertical ? {\n      bottom: handlePosition\n    } : {\n      left: handlePosition\n    }, {}, style)\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  SliderHandle.displayName = \"SliderHandle\";\n  SliderHandle.propTypes = {};\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * SliderMarker\r\n *\r\n * A fixed value marker. These can be used to illustrate a range of steps or\r\n * highlight important points along the slider track.\r\n *\r\n * @see Docs https://reacttraining.com/reach-ui/slider#slidermarker\r\n */\n\n\nvar SliderMarker = /*#__PURE__*/forwardRef(function SliderMarker(_ref6, forwardedRef) {\n  var children = _ref6.children,\n      _ref6$style = _ref6.style,\n      style = _ref6$style === void 0 ? {} : _ref6$style,\n      value = _ref6.value,\n      props = _objectWithoutPropertiesLoose(_ref6, [\"children\", \"style\", \"value\"]);\n\n  var _useSliderContext4 = useSliderContext(),\n      disabled = _useSliderContext4.disabled,\n      isVertical = _useSliderContext4.isVertical,\n      orientation = _useSliderContext4.orientation,\n      sliderMin = _useSliderContext4.sliderMin,\n      sliderMax = _useSliderContext4.sliderMax,\n      sliderValue = _useSliderContext4.value;\n\n  var inRange = !(value < sliderMin || value > sliderMax);\n  var absoluteStartPosition = valueToPercent(value, sliderMin, sliderMax) + \"%\";\n  var state = value < sliderValue ? \"under-value\" : value === sliderValue ? \"at-value\" : \"over-value\";\n  return inRange ? React.createElement(\"div\", Object.assign({\n    ref: forwardedRef,\n    style: _extends({\n      position: \"absolute\"\n    }, isVertical ? {\n      bottom: absoluteStartPosition\n    } : {\n      left: absoluteStartPosition\n    }, {}, style)\n  }, props, {\n    \"data-reach-slider-marker\": \"\",\n    \"data-disabled\": disabled ? \"\" : undefined,\n    \"data-orientation\": orientation,\n    \"data-state\": state,\n    \"data-value\": value,\n    children: children\n  })) : null;\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  SliderMarker.displayName = \"SliderMarker\";\n  SliderMarker.propTypes = {\n    value: PropTypes.number.isRequired\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nfunction getAllowedValue(val, min, max) {\n  return val > max ? max : val < min ? min : val;\n}\n\nfunction makeValuePrecise(value, step) {\n  var stepDecimalPart = step.toString().split(\".\")[1];\n  var stepPrecision = stepDecimalPart ? stepDecimalPart.length : 0;\n  return Number(value.toFixed(stepPrecision));\n}\n\nfunction percentToValue(percent, min, max) {\n  return (max - min) * percent + min;\n}\n\nfunction roundValueToStep(value, step) {\n  return makeValuePrecise(Math.round(value / step) * step, step);\n}\n\nfunction useDimensions(ref) {\n  var _useState4 = useState({\n    width: 0,\n    height: 0\n  }),\n      _useState4$ = _useState4[0],\n      width = _useState4$.width,\n      height = _useState4$.height,\n      setDimensions = _useState4[1]; // Many existing `useDimensions` type hooks will use `getBoundingClientRect`\n  // getBoundingClientRect does not work here when borders are applied.\n  // getComputedStyle is not as performant so we may want to create a utility to\n  // check for any conflicts with box sizing first and only use\n  // `getComputedStyle` if neccessary.\n\n  /* const { width, height } = ref.current\r\n    ? ref.current.getBoundingClientRect()\r\n    : 0; */\n\n\n  useIsomorphicLayoutEffect(function () {\n    if (ref.current) {\n      var _window$getComputedSt = window.getComputedStyle(ref.current),\n          _newHeight = _window$getComputedSt.height,\n          _newWidth = _window$getComputedSt.width;\n\n      var newHeight = parseFloat(_newHeight);\n      var newWidth = parseFloat(_newWidth);\n\n      if (newHeight !== height || newWidth !== width) {\n        setDimensions({\n          height: newHeight,\n          width: newWidth\n        });\n      }\n    }\n  }, [ref, width, height]);\n  return {\n    ref: ref,\n    width: width,\n    height: height\n  };\n}\n\nfunction valueToPercent(value, min, max) {\n  return (value - min) * 100 / (max - min);\n}\n\nexport default Slider;\nexport { SLIDER_HANDLE_ALIGN_CENTER, SLIDER_HANDLE_ALIGN_CONTAIN, SLIDER_ORIENTATION_HORIZONTAL, SLIDER_ORIENTATION_VERTICAL, Slider, SliderHandle, SliderHandleAlignment, SliderInput, SliderMarker, SliderOrientation, SliderTrack, SliderTrackHighlight };","map":{"version":3,"sources":["../src/index.tsx"],"names":["SliderOrientation","SliderHandleAlignment","SLIDER_ORIENTATION_HORIZONTAL","Horizontal","SLIDER_ORIENTATION_VERTICAL","Vertical","SLIDER_HANDLE_ALIGN_CENTER","Center","SLIDER_HANDLE_ALIGN_CONTAIN","Contain","SliderContext","createNamedContext","useSliderContext","useContext","sliderPropTypes","defaultValue","PropTypes","disabled","getValueText","handleAlignment","min","max","name","orientation","onChange","step","value","number","Slider","forwardRef","children","props","React","ref","forwardedRef","node","SliderInput","ariaLabel","ariaLabelledBy","ariaValueText","controlledValue","onKeyDown","onPointerDown","onPointerMove","onPointerUp","stepProp","rest","current","isControlled","useRef","id","useId","trackRef","handleRef","sliderRef","useForkedRef","hasFocus","setHasFocus","useState","isPointerDown","setPointerDown","internalValue","setValue","handleDimensions","useDimensions","_value","getAllowedValue","trackPercent","valueToPercent","isVertical","handleSize","handlePosition","updateValue","useCallback","getNewValueFromPointer","left","width","bottom","height","clientX","clientY","event","diff","percent","newValue","percentToValue","roundValueToStep","handleKeyDown","wrapEvent","flag","tenSteps","keyStep","handlePointerDown","handlePointerUp","valueText","trackHighlightStyle","ctx","onHandleKeyDown","sliderId","sliderMax","sliderMin","sliderStep","useEffect","ownerDocument","getOwnerDocument","handlePointerMove","checkStyles","undefined","tabIndex","type","makeId","isRequired","SliderTrack","style","position","SliderTrackHighlight","SliderHandle","onBlur","onFocus","role","SliderMarker","sliderValue","inRange","absoluteStartPosition","state","val","stepDecimalPart","stepPrecision","Number","makeValuePrecise","Math","setDimensions","useIsomorphicLayoutEffect","_newHeight","_newWidth","window","newHeight","parseFloat","newWidth"],"mappings":"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","sourcesContent":["/**\n * Welcome to @reach/slider!\n *\n * A UI input component where the user selects a value from within a given\n * range. A Slider has a handle that can be moved along a track to change its\n * value. When the user's mouse or focus is on the Slider's handle, the value\n * can be incremented with keyboard controls.\n *\n * Random thoughts/notes:\n *  - Currently testing this against the behavior of the native input range\n *    element to get our slider on par. We'll explore animated and multi-handle\n *    sliders next.\n *  - We may want to research some use cases for reversed sliders in RTL\n *    languages if that's a thing\n *\n * @see Docs     https://reacttraining.com/reach-ui/slider\n * @see Source   https://github.com/reach/reach-ui/tree/master/packages/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#slider\n * @see          https://github.com/Stanko/aria-progress-range-slider\n * @see          http://www.oaa-accessibility.org/examplep/slider1/\n */\n\nimport React, {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"warning\";\nimport { useId } from \"@reach/auto-id\";\nimport {\n  checkStyles,\n  createNamedContext,\n  getOwnerDocument,\n  isFunction,\n  makeId,\n  useForkedRef,\n  useIsomorphicLayoutEffect,\n  wrapEvent,\n} from \"@reach/utils\";\n\nexport type SliderAlignment = \"center\" | \"contain\";\nexport enum SliderOrientation {\n  Horizontal = \"horizontal\",\n  Vertical = \"vertical\",\n}\nexport enum SliderHandleAlignment {\n  // Handle is centered directly over the current value marker\n  Center = \"center\",\n  // Handle is contained within the bounds of the track, offset slightly from\n  // the value's center mark to accommodate\n  Contain = \"contain\",\n}\n\n// TODO: Remove in 1.0, maybe?\nexport const SLIDER_ORIENTATION_HORIZONTAL = SliderOrientation.Horizontal;\nexport const SLIDER_ORIENTATION_VERTICAL = SliderOrientation.Vertical;\nexport const SLIDER_HANDLE_ALIGN_CENTER = SliderHandleAlignment.Center;\nexport const SLIDER_HANDLE_ALIGN_CONTAIN = SliderHandleAlignment.Contain;\n\nconst SliderContext = createNamedContext<ISliderContext>(\n  \"SliderContext\",\n  {} as ISliderContext\n);\nconst useSliderContext = () => useContext(SliderContext);\n\n// These proptypes are shared between the composed SliderInput component and the\n// simplified Slider\nconst sliderPropTypes = {\n  defaultValue: PropTypes.number,\n  disabled: PropTypes.bool,\n  getValueText: PropTypes.func,\n  handleAlignment: PropTypes.oneOf([\n    SliderHandleAlignment.Center,\n    SliderHandleAlignment.Contain,\n  ]),\n  min: PropTypes.number,\n  max: PropTypes.number,\n  name: PropTypes.string,\n  orientation: PropTypes.oneOf([\n    SliderOrientation.Horizontal,\n    SliderOrientation.Vertical,\n  ]),\n  onChange: PropTypes.func,\n  step: PropTypes.number,\n  value: PropTypes.number,\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Slider\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slider\n */\nexport const Slider = forwardRef<HTMLDivElement, SliderProps>(function Slider(\n  { children, ...props },\n  forwardedRef\n) {\n  return (\n    <SliderInput ref={forwardedRef} data-reach-slider=\"\" {...props}>\n      <SliderTrack>\n        <SliderTrackHighlight />\n        <SliderHandle />\n        {children}\n      </SliderTrack>\n    </SliderInput>\n  );\n});\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/slider#slider-props\n */\nexport type SliderProps = Omit<\n  React.HTMLAttributes<HTMLDivElement>,\n  \"onChange\" | \"onPointerMove\"\n> & {\n  /**\n   * `Slider` can accept `SliderMarker` children to enhance display of specific\n   * values along the track.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-children\n   */\n  children?: React.ReactNode;\n  /**\n   * The defaultValue is used to set an initial value for an uncontrolled\n   * Slider.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-defaultvalue\n   */\n  defaultValue?: number;\n  /**\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-disabled\n   */\n  disabled?: boolean;\n  /**\n   * Whether or not the slider should be disabled from user interaction.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-value\n   */\n  value?: number;\n  /**\n   * A function used to set human readable value text based on the slider's\n   * current value.\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-getvaluetext\n   */\n  getValueText?(value: number): string;\n  /**\n   * When set to `center`, the slider's handle will be positioned directly\n   * centered over the slider's curremt value on the track. This means that when\n   * the slider is at its min or max value, a visiable slider handle will extend\n   * beyond the width (or height in vertical mode) of the slider track. When set\n   * to `contain`, the slider handle will always be contained within the bounds\n   * of the track, meaning its position will be slightly offset from the actual\n   * value depending on where it sits on the track.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-handlealignment\n   */\n  handleAlignment?: \"center\" | \"contain\" | SliderAlignment;\n  /**\n   * The maximum value of the slider. Defaults to `100`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-max\n   */\n  max?: number;\n  /**\n   * The minimum value of the slider. Defaults to `0`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-min\n   */\n  min?: number;\n  /**\n   * If the slider is used as a form input, it should accept a `name` prop to\n   * identify its value in context of the form.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-name\n   */\n  name?: string;\n  /**\n   * Callback that fires when the slider value changes. When the `value` prop is\n   * set, the Slider state becomes controlled and `onChange` must be used to\n   * update the value in response to user interaction.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-onchange\n   */\n  onChange?(\n    newValue: number,\n    props?: {\n      min?: number;\n      max?: number;\n      handlePosition?: string;\n    }\n  ): void;\n  onPointerMove?(event: PointerEvent): void;\n  /**\n   * Sets the slider to horizontal or vertical mode.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-orientation\n   */\n  orientation?: SliderOrientation;\n  /**\n   * The step attribute is a number that specifies the granularity that the\n   * value must adhere to as it changes. Step sets minimum intervals of change,\n   * creating a \"snap\" effect when the handle is moved along the track.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slider-step\n   */\n  step?: number;\n};\n\nif (__DEV__) {\n  Slider.displayName = \"Slider\";\n  Slider.propTypes = {\n    ...sliderPropTypes,\n    children: PropTypes.node,\n  };\n}\n\nexport default Slider;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderInput\n *\n * The parent component of the slider interface. This is a lower level component\n * if you need more control over styles or rendering the slider's inner\n * components.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderinput\n */\nexport const SliderInput = forwardRef<HTMLDivElement, SliderInputProps>(\n  function SliderInput(\n    {\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-valuetext\": ariaValueText,\n      defaultValue,\n      disabled = false,\n      value: controlledValue,\n      getValueText,\n      handleAlignment = SliderHandleAlignment.Center,\n      max = 100,\n      min = 0,\n      name,\n      onChange,\n      onKeyDown,\n      onPointerDown,\n      onPointerMove,\n      onPointerUp,\n      orientation = SliderOrientation.Horizontal,\n      step: stepProp,\n      children,\n      ...rest\n    },\n    forwardedRef\n  ) {\n    // Verify that the component is either controlled or uncontrolled throughout\n    // its lifecycle\n    const { current: isControlled } = useRef(controlledValue != null);\n\n    warning(\n      !(isControlled && controlledValue == null),\n      \"Slider is changing from controlled to uncontrolled. Slider should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Slider for the lifetime of the component. Check the `value` prop being passed in.\"\n    );\n\n    warning(\n      !(!isControlled && controlledValue != null),\n      \"Slider is changing from uncontrolled to controlled. Slider should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled Slider for the lifetime of the component. Check the `value` prop being passed in.\"\n    );\n\n    const id = useId(rest.id);\n\n    const trackRef: TrackRef = useRef(null);\n    const handleRef: HandleRef = useRef(null);\n    const sliderRef: SliderRef = useRef(null);\n    const ref = useForkedRef(sliderRef, forwardedRef);\n\n    const [hasFocus, setHasFocus] = useState(false);\n    const [isPointerDown, setPointerDown] = useState(false);\n    const [internalValue, setValue] = useState(defaultValue || min);\n\n    const { ref: x, ...handleDimensions } = useDimensions(handleRef);\n\n    const _value = isControlled ? (controlledValue as number) : internalValue;\n    const value = getAllowedValue(_value, min, max);\n    const trackPercent = valueToPercent(value, min, max);\n    const isVertical = orientation === SliderOrientation.Vertical;\n    const step = stepProp || 1;\n\n    const handleSize = isVertical\n      ? handleDimensions.height\n      : handleDimensions.width;\n\n    const handlePosition = `calc(${trackPercent}% - ${\n      handleAlignment === SliderHandleAlignment.Center\n        ? `${handleSize}px / 2`\n        : `${handleSize}px * ${trackPercent * 0.01}`\n    })`;\n\n    const updateValue = useCallback(\n      function updateValue(newValue) {\n        if (!isControlled) {\n          setValue(newValue);\n        }\n        if (onChange) {\n          onChange(newValue, { min, max, handlePosition });\n        }\n      },\n      [handlePosition, isControlled, max, min, onChange]\n    );\n\n    const getNewValueFromPointer = useCallback(\n      (event: React.PointerEvent | PointerEvent) => {\n        if (trackRef.current) {\n          const {\n            left,\n            width,\n            bottom,\n            height,\n          } = trackRef.current.getBoundingClientRect();\n          const { clientX, clientY } = event;\n          let diff = isVertical ? bottom - clientY : clientX - left;\n          let percent = diff / (isVertical ? height : width);\n          let newValue = percentToValue(percent, min, max);\n\n          if (step) {\n            newValue = roundValueToStep(newValue, step);\n          }\n          newValue = getAllowedValue(newValue, min, max);\n          return newValue;\n        }\n        return null;\n      },\n      [isVertical, max, min, step]\n    );\n\n    // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_kbd_interaction\n    const handleKeyDown = wrapEvent(onKeyDown, event => {\n      let flag = false;\n      let newValue;\n      const tenSteps = (max - min) / 10;\n      const keyStep = stepProp || (max - min) / 100;\n\n      switch (event.key) {\n        // Decrease the value of the slider by one step.\n        case \"ArrowLeft\":\n        case \"ArrowDown\":\n          newValue = value - keyStep;\n          flag = true;\n          break;\n        // Increase the value of the slider by one step\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n          newValue = value + keyStep;\n          flag = true;\n          break;\n        // Decrement the slider by an amount larger than the step change made by\n        // `ArrowDown`.\n        case \"PageDown\":\n          newValue = value - tenSteps;\n          flag = true;\n          break;\n        // Increment the slider by an amount larger than the step change made by\n        // `ArrowUp`.\n        case \"PageUp\":\n          newValue = value + tenSteps;\n          flag = true;\n          break;\n        // Set the slider to the first allowed value in its range.\n        case \"Home\":\n          newValue = min;\n          flag = true;\n          break;\n        // Set the slider to the last allowed value in its range.\n        case \"End\":\n          newValue = max;\n          flag = true;\n          break;\n        default:\n          return;\n      }\n\n      if (flag) {\n        event.preventDefault();\n        newValue = roundValueToStep(newValue, keyStep);\n        newValue = getAllowedValue(newValue, min, max);\n        updateValue(newValue);\n      }\n    });\n\n    const handlePointerDown = wrapEvent(onPointerDown, event => {\n      event.preventDefault();\n      if (disabled) {\n        if (isPointerDown) setPointerDown(false);\n        return;\n      }\n      if (sliderRef.current && handleRef.current) {\n        setPointerDown(true);\n        const newValue = getNewValueFromPointer(event);\n        sliderRef.current.setPointerCapture &&\n          sliderRef.current.setPointerCapture(event.pointerId);\n        if (newValue != null && newValue !== value) {\n          updateValue(newValue);\n        }\n        handleRef.current.focus();\n      }\n    });\n\n    const handlePointerUp = wrapEvent(onPointerUp, function(event) {\n      if (sliderRef.current && event.pointerId) {\n        sliderRef.current.releasePointerCapture &&\n          sliderRef.current.releasePointerCapture(event.pointerId);\n      }\n      setPointerDown(false);\n    });\n\n    const valueText = getValueText ? getValueText(value) : ariaValueText;\n\n    const trackHighlightStyle = isVertical\n      ? {\n          width: `100%`,\n          height: `${trackPercent}%`,\n          bottom: 0,\n        }\n      : {\n          width: `${trackPercent}%`,\n          height: `100%`,\n          left: 0,\n        };\n\n    const ctx: ISliderContext = {\n      ariaLabel,\n      ariaLabelledBy,\n      handleDimensions,\n      handlePosition,\n      handleRef,\n      hasFocus,\n      onKeyDown,\n      onPointerDown,\n      onPointerMove,\n      onPointerUp,\n      onHandleKeyDown: handleKeyDown,\n      setHasFocus,\n      sliderId: id,\n      sliderMax: max,\n      sliderMin: min,\n      value,\n      valueText,\n      disabled: !!disabled,\n      isVertical,\n      orientation,\n      sliderStep: step,\n      trackPercent,\n      trackRef,\n      trackHighlightStyle,\n      updateValue,\n    };\n\n    useEffect(() => {\n      const ownerDocument = getOwnerDocument(sliderRef.current) || document;\n      const handlePointerMove = wrapEvent(onPointerMove, event => {\n        const newValue = getNewValueFromPointer(event);\n        if (newValue !== value) {\n          updateValue(newValue);\n        }\n      });\n\n      if (isPointerDown) {\n        ownerDocument.addEventListener(\"pointermove\", handlePointerMove);\n      }\n\n      return () => {\n        ownerDocument.removeEventListener(\"pointermove\", handlePointerMove);\n      };\n    }, [\n      getNewValueFromPointer,\n      isPointerDown,\n      onPointerMove,\n      updateValue,\n      value,\n    ]);\n\n    useEffect(() => checkStyles(\"slider\"), []);\n\n    return (\n      <SliderContext.Provider value={ctx}>\n        <div\n          {...rest}\n          ref={ref}\n          data-reach-slider-input=\"\"\n          data-disabled={disabled ? \"\" : undefined}\n          data-orientation={orientation}\n          tabIndex={-1}\n          onPointerDown={handlePointerDown}\n          onPointerUp={handlePointerUp}\n        >\n          {isFunction(children)\n            ? children({\n                hasFocus,\n                id,\n                max,\n                min,\n                value,\n                valueText,\n              })\n            : children}\n          {name && (\n            // If the slider is used in a form we'll need an input field to\n            // capture the value. We'll assume this when the component is given a\n            // form field name (A `name` prop doesn't really make sense in any\n            // other context).\n            <input\n              type=\"hidden\"\n              value={value}\n              name={name}\n              id={id && makeId(\"input\", id)}\n            />\n          )}\n        </div>\n      </SliderContext.Provider>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderinput-props\n */\nexport type SliderInputProps = Omit<SliderProps, \"children\"> & {\n  /**\n   * Slider expects `<SliderTrack>` as its child; The track will accept all\n   * additional slider sub-components as children. It can also accept a\n   * function/render prop as its child to expose some of its internal state\n   * variables.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#sliderinput-children\n   */\n  children: React.ReactNode | SliderChildrenRender;\n};\n\nif (__DEV__) {\n  SliderInput.displayName = \"SliderInput\";\n  SliderInput.propTypes = {\n    ...sliderPropTypes,\n    children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderTrack\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrack\n */\nexport const SliderTrack = forwardRef<HTMLDivElement, SliderTrackProps>(\n  function SliderTrack({ children, style = {}, ...props }, forwardedRef) {\n    const { disabled, orientation, trackRef } = useSliderContext();\n    const ref = useForkedRef(trackRef, forwardedRef);\n\n    return (\n      <div\n        ref={ref}\n        style={{ ...style, position: \"relative\" }}\n        {...props}\n        data-reach-slider-track=\"\"\n        data-disabled={disabled ? \"\" : undefined}\n        data-orientation={orientation}\n      >\n        {children}\n      </div>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrack-props\n */\nexport type SliderTrackProps = React.HTMLAttributes<HTMLDivElement> & {\n  /**\n   * `SliderTrack` expects `<SliderHandle>`, at minimum, for the Slider to\n   * function. All other Slider subcomponents should be passed as children\n   * inside the `SliderTrack`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slidertrack-children\n   */\n  children: React.ReactNode;\n};\n\nif (__DEV__) {\n  SliderTrack.displayName = \"SliderTrack\";\n  SliderTrack.propTypes = {\n    children: PropTypes.node.isRequired,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderTrackHighlight\n *\n * The (typically) highlighted portion of the track that represents the space\n * between the slider's `min` value and its current value.\n *\n * TODO: Consider renaming to `SliderTrackProgress`\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrackhighlight\n */\nexport const SliderTrackHighlight = forwardRef<\n  HTMLDivElement,\n  SliderTrackHighlightProps\n>(function SliderTrackHighlight(\n  { children, style = {}, ...props },\n  forwardedRef\n) {\n  let { disabled, orientation, trackHighlightStyle } = useSliderContext();\n  return (\n    <div\n      ref={forwardedRef}\n      style={{ position: \"absolute\", ...trackHighlightStyle, ...style }}\n      {...props}\n      data-reach-slider-track-highlight=\"\"\n      data-disabled={disabled ? \"\" : undefined}\n      data-orientation={orientation}\n    />\n  );\n});\n\n/**\n * `SliderTrackHighlight` accepts any props that a HTML div component accepts.\n * `SliderTrackHighlight` will not accept or render any children.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slidertrackhighlight-props\n */\nexport type SliderTrackHighlightProps = React.HTMLAttributes<HTMLDivElement>;\n\nif (__DEV__) {\n  SliderTrackHighlight.displayName = \"SliderTrackHighlight\";\n  SliderTrackHighlight.propTypes = {};\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderHandle\n *\n * The handle that the user drags along the track to set the slider value.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderhandle\n */\nexport const SliderHandle = forwardRef<HTMLDivElement, SliderHandleProps>(\n  function SliderHandle(\n    {\n      // min,\n      // max,\n      onBlur,\n      onFocus,\n      style = {},\n      onKeyDown,\n      ...props\n    },\n    forwardedRef\n  ) {\n    const {\n      ariaLabel,\n      ariaLabelledBy,\n      disabled,\n      handlePosition,\n      handleRef,\n      isVertical,\n      onHandleKeyDown,\n      orientation,\n      setHasFocus,\n      sliderMin,\n      sliderMax,\n      value,\n      valueText,\n    } = useSliderContext();\n\n    const ref = useForkedRef(handleRef, forwardedRef);\n\n    return (\n      <div\n        aria-disabled={disabled || undefined}\n        // If the slider has a visible label, it is referenced by\n        // `aria-labelledby` on the slider element. Otherwise, the slider\n        // element has a label provided by `aria-label`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabel ? undefined : ariaLabelledBy}\n        // If the slider is vertically oriented, it has `aria-orientation` set\n        // to vertical. The default value of `aria-orientation` for a slider is\n        // horizontal.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-orientation={orientation}\n        // The slider element has the `aria-valuemax` property set to a decimal\n        // value representing the maximum allowed value of the slider.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-valuemax={sliderMax}\n        // The slider element has the `aria-valuemin` property set to a decimal\n        // value representing the minimum allowed value of the slider.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-valuemin={sliderMin}\n        // The slider element has the `aria-valuenow` property set to a decimal\n        // value representing the current value of the slider.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-valuenow={value}\n        // If the value of `aria-valuenow` is not user-friendly, e.g., the day\n        // of the week is represented by a number, the `aria-valuetext` property\n        // is set to a string that makes the slider value understandable, e.g.,\n        // \"Monday\".\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        aria-valuetext={valueText}\n        // The element serving as the focusable slider control has role\n        // `slider`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#slider_roles_states_props\n        role=\"slider\"\n        tabIndex={disabled ? -1 : 0}\n        {...props}\n        data-reach-slider-handle=\"\"\n        ref={ref}\n        onBlur={wrapEvent(onBlur, () => {\n          setHasFocus(false);\n        })}\n        onFocus={wrapEvent(onFocus, () => {\n          setHasFocus(true);\n        })}\n        onKeyDown={wrapEvent(onKeyDown, onHandleKeyDown)}\n        style={{\n          position: \"absolute\",\n          ...(isVertical\n            ? { bottom: handlePosition }\n            : { left: handlePosition }),\n          ...style,\n        }}\n      />\n    );\n  }\n);\n\n/**\n * `SliderTrackHighlight` accepts any props that a HTML div component accepts.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#sliderhandle-props\n */\nexport type SliderHandleProps = React.HTMLAttributes<HTMLDivElement>;\n\nif (__DEV__) {\n  SliderHandle.displayName = \"SliderHandle\";\n  SliderHandle.propTypes = {};\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * SliderMarker\n *\n * A fixed value marker. These can be used to illustrate a range of steps or\n * highlight important points along the slider track.\n *\n * @see Docs https://reacttraining.com/reach-ui/slider#slidermarker\n */\nexport const SliderMarker = forwardRef<HTMLDivElement, SliderMarkerProps>(\n  function SliderMarker(\n    { children, style = {}, value, ...props },\n    forwardedRef\n  ) {\n    const {\n      disabled,\n      isVertical,\n      orientation,\n      sliderMin,\n      sliderMax,\n      value: sliderValue,\n    } = useSliderContext();\n\n    let inRange = !(value < sliderMin || value > sliderMax);\n    let absoluteStartPosition = `${valueToPercent(\n      value,\n      sliderMin,\n      sliderMax\n    )}%`;\n\n    let state =\n      value < sliderValue\n        ? \"under-value\"\n        : value === sliderValue\n        ? \"at-value\"\n        : \"over-value\";\n\n    return inRange ? (\n      <div\n        ref={forwardedRef}\n        style={{\n          position: \"absolute\",\n          ...(isVertical\n            ? { bottom: absoluteStartPosition }\n            : { left: absoluteStartPosition }),\n          ...style,\n        }}\n        {...props}\n        data-reach-slider-marker=\"\"\n        data-disabled={disabled ? \"\" : undefined}\n        data-orientation={orientation}\n        data-state={state}\n        data-value={value}\n        children={children}\n      />\n    ) : null;\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/slider#slidermarker-props\n */\nexport type SliderMarkerProps = React.HTMLAttributes<HTMLDivElement> & {\n  /**\n   * The value to denote where the marker should appear along the track.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/slider#slidermarker-value\n   */\n  value: number;\n};\n\nif (__DEV__) {\n  SliderMarker.displayName = \"SliderMarker\";\n  SliderMarker.propTypes = {\n    value: PropTypes.number.isRequired,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\nfunction getAllowedValue(val: number, min: number, max: number) {\n  return val > max ? max : val < min ? min : val;\n}\n\nfunction makeValuePrecise(value: number, step: number) {\n  const stepDecimalPart = step.toString().split(\".\")[1];\n  const stepPrecision = stepDecimalPart ? stepDecimalPart.length : 0;\n  return Number(value.toFixed(stepPrecision));\n}\n\nfunction percentToValue(percent: number, min: number, max: number) {\n  return (max - min) * percent + min;\n}\n\nfunction roundValueToStep(value: number, step: number) {\n  return makeValuePrecise(Math.round(value / step) * step, step);\n}\n\nfunction useDimensions(ref: React.RefObject<HTMLElement | null>) {\n  const [{ width, height }, setDimensions] = useState({ width: 0, height: 0 });\n  // Many existing `useDimensions` type hooks will use `getBoundingClientRect`\n  // getBoundingClientRect does not work here when borders are applied.\n  // getComputedStyle is not as performant so we may want to create a utility to\n  // check for any conflicts with box sizing first and only use\n  // `getComputedStyle` if neccessary.\n  /* const { width, height } = ref.current\n    ? ref.current.getBoundingClientRect()\n    : 0; */\n\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current) {\n      const { height: _newHeight, width: _newWidth } = window.getComputedStyle(\n        ref.current\n      );\n      let newHeight = parseFloat(_newHeight);\n      let newWidth = parseFloat(_newWidth);\n\n      if (newHeight !== height || newWidth !== width) {\n        setDimensions({ height: newHeight, width: newWidth });\n      }\n    }\n  }, [ref, width, height]);\n  return { ref, width, height };\n}\n\nfunction valueToPercent(value: number, min: number, max: number) {\n  return ((value - min) * 100) / (max - min);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype TrackRef = React.RefObject<HTMLDivElement | null>;\ntype HandleRef = React.RefObject<HTMLDivElement | null>;\ntype SliderRef = React.RefObject<HTMLDivElement | null>;\n\ninterface ISliderContext {\n  ariaLabel: string | undefined;\n  ariaLabelledBy: string | undefined;\n  handleDimensions: {\n    width: number;\n    height: number;\n  };\n  handlePosition: string;\n  handleRef: HandleRef;\n  hasFocus: boolean;\n  onKeyDown?: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n  onPointerDown?: (event: React.PointerEvent<HTMLDivElement>) => void;\n  onPointerMove?: (event: PointerEvent) => void;\n  onPointerUp?: (event: React.PointerEvent<HTMLDivElement>) => void;\n  onHandleKeyDown: (event: React.KeyboardEvent<HTMLDivElement>) => void;\n  setHasFocus: React.Dispatch<React.SetStateAction<boolean>>;\n  sliderId: string | undefined;\n  sliderMax: number;\n  sliderMin: number;\n  value: number;\n  valueText: string | undefined;\n  disabled: boolean;\n  isVertical: boolean;\n  orientation: SliderOrientation;\n  sliderStep: number;\n  trackPercent: number;\n  trackRef: TrackRef;\n  trackHighlightStyle: React.CSSProperties;\n  updateValue: (newValue: any) => void;\n}\n\ntype SliderChildrenRender = (props: {\n  hasFocus?: boolean;\n  id?: string | undefined;\n  sliderId?: string | undefined;\n  max?: number;\n  min?: number;\n  value?: number;\n  valueText?: string | undefined;\n}) => JSX.Element;\n"]},"metadata":{},"sourceType":"module"}